{"version":3,"sources":["src/store/auth/utils/verify-auth.js"],"names":["fetchToken","C","parseHeaders","headers","newHeaders","blankHeaders","key","rawEndpoints","cookies","currentLocation","parse","authRedirectHeaders","resolve","reject","validationUrl","currentEndpoint","defaultEndpointKey","apiUrl","tokenValidationPath","rawCookies","parsedCookies","JSON","authHeaders","firstTimeLogin","mustResetPassword","currentEndpointKey","uid","endpointKey","reset_password","account_confirmation_success","SAVED_CONFIG_KEY","reason","then","resp","raw","json","success","user","data","errors","catch","verifyAuth","isServer","res"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAsCgBA,U,GAAAA,U;;AAtChB;;;;AACA;;;;AACA;;;;AACA;;IAAYC,C;;AACZ;;AACA;;;;AACA;;;;;;;;AAEA,SAASC,YAAT,CAAuBC,OAAvB,EAAgC;AAC9B;AACA,MAAIC,aAAa,EAAjB;;AAEA;AACA;AACA,MAAIC,eAAe,IAAnB;;AAEA;AACA;AAT8B,SAUd,CAAC,cAAD,EAAiB,YAAjB,EAA+B,QAA/B,EAAyC,QAAzC,EAAmD,KAAnD,EAA0D,QAA1D,EAAoE,aAApE,CAVc;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAU9B,oKAAoG;AAAA;;AAAA,UAA3FC,GAA2F;;AAClGF,iBAAWE,GAAX,IAAkBH,QAAQG,GAAR,CAAlB;;AAEA,UAAIF,WAAWE,GAAX,CAAJ,EAAqB;AACnB;AACA,YAAI,sBAAOF,WAAWE,GAAX,CAAP,MAA2B,QAA/B,EAAyC;AACvCF,qBAAWE,GAAX,IAAkBF,WAAWE,GAAX,EAAgB,CAAhB,CAAlB;AACD;;AAEDD,uBAAe,KAAf;AACD;AACF;;AAED;AAvB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwB9B,MAAI,CAACA,YAAL,EAAmB;AACjB,WAAOD,UAAP;AACD;AACF;;AAGM,SAASJ,UAAT,QAA8D;AAAA,MAAzCO,YAAyC,SAAzCA,YAAyC;AAAA,MAA3BC,OAA2B,SAA3BA,OAA2B;AAAA,MAAlBC,eAAkB,SAAlBA,eAAkB;;AAAA,yBACvC,wBAAgB,cAAIC,KAAJ,CAAUD,eAAV,CAAhB,CADuC;AAAA,MAC9DE,mBAD8D,oBAC9DA,mBAD8D;;AAGnE,SAAO,sBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAIL,WAAWG,mBAAf,EAAoC;AAAA,UA4B9BP,UA5B8B,EA+B9BU,aA/B8B,EA6B7BC,eA7B6B,EA6BZC,kBA7BY,EA8B7BC,MA9B6B,EA8BrBC,mBA9BqB;;AAAA;AAClC,YAAIC,aAAa,iBAAOT,KAAP,CAAaF,WAAW,IAAxB,CAAjB;AACA,YAAIY,gBAAgBC,KAAKX,KAAL,CAAWS,WAAWG,WAAX,IAA0B,OAArC,CAApB;AACA,YAAIC,uBAAJ;AAAA,YACIC,0BADJ;AAAA,YAEIC,2BAFJ;AAAA,YAGItB,gBAHJ;;AAKA,YAAIQ,uBAAuBA,oBAAoBe,GAA3C,IAAkDf,oBAAoB,cAApB,CAAtD,EAA2F;AACzFR,oBAAqBD,aAAaS,mBAAb,CAArB;AACAc,+BAAqBd,oBAAoBgB,WAApB,IAAmC,IAAxD;AACAH,8BAAqBH,KAAKX,KAAL,CAAWC,oBAAoBiB,cAApB,IAAsC,OAAjD,CAArB;AACAL,2BAAqBF,KAAKX,KAAL,CAAWC,oBAAoBkB,4BAApB,IAAoD,OAA/D,CAArB;AACD,SALD,MAKO,IAAIV,cAAcC,aAAlB,EAAiC;AACtCjB,oBAAqBiB,aAArB;AACAK,+BAAqBJ,KAAKX,KAAL,CAAWS,WAAWlB,EAAE6B,gBAAb,KAAkC,MAA7C,CAArB;AACAN,8BAAqBH,KAAKX,KAAL,CAAWU,cAAcI,iBAAd,IAAmC,OAA9C,CAArB;AACAD,2BAAqBF,KAAKX,KAAL,CAAWU,cAAcG,cAAd,IAAgC,OAA3C,CAArB;AACD;;AAED,YAAI,CAACpB,OAAL,EAAc;AACZ;AAAA,eAAOU,OAAO;AACZkB,sBAAQ,UADI;AAEZhB,8CAFY;AAGZC;AAHY,aAAP;AAAP;AAKD;;AA1BiC,mCA6BU,mCAAoBT,YAApB,CA7BV;;AA6B7BQ,uBA7B6B,wBA6B7BA,eA7B6B;AA6BZC,0BA7BY,wBA6BZA,kBA7BY;AAAA,+BA8BED,gBAAgBU,sBAAsBT,kBAAtC,CA9BF;AA8B7BC,cA9B6B,oBA8B7BA,MA9B6B;AA8BrBC,2BA9BqB,oBA8BrBA,mBA9BqB;AA+B9BJ,6BAAmBG,MAAnB,GAA4BC,mBAA5B,kBA/B8B;;;AAiClC;AAAA,aAAO,+BAAMJ,aAAN,EAAqB;AAC1BX,qBAAS,mCAAuBA,QAAQ,cAAR,CAAvB,EAAgDA,OAAhD;AADiB,WAArB,EAEJ6B,IAFI,CAEC,UAACC,IAAD,EAAU;AAChB7B,yBAAaF,aAAa+B,KAAK9B,OAAL,CAAa+B,GAAb,EAAb,CAAb;AACA,mBAAOD,KAAKE,IAAL,EAAP;AACD,WALM,EAMNH,IANM,CAMD,UAACG,IAAD,EAAU;AACd,gBAAIA,KAAKC,OAAT,EAAkB;AAChB,qBAAOxB,QAAQ;AACbT,yBAASC,UADI;AAEbiC,sBAAMF,KAAKG,IAFE;AAGbd,oDAHa;AAIbD,8CAJa;AAKbR,gDALa;AAMbU,sDANa;AAObT;AAPa,eAAR,CAAP;AASD,aAVD,MAUO;AACL,qBAAOH,OAAO;AACZkB,wBAAQI,KAAKI,MADD;AAEZf,oDAFY;AAGZD,8CAHY;AAIZR,gDAJY;AAKZC;AALY,eAAP,CAAP;AAOD;AACF,WA1BM,EA0BJwB,KA1BI,CA0BE,kBAAU;AACjB,mBAAO3B,OAAO;AACZkB,4BADY;AAEZR,4CAFY;AAGZC,kDAHY;AAIZT,8CAJY;AAKZC;AALY,aAAP,CAAP;AAOD,WAlCM;AAAP;AAjCkC;;AAAA;AAoEnC,KApED,MAoEO;AAAA,kCACuC,mCAAoBT,YAApB,CADvC;AAAA,UACAQ,iBADA,yBACAA,eADA;AAAA,UACiBC,mBADjB,yBACiBA,kBADjB;;AAELH,aAAO;AACLkB,gBAAQ,UADH;AAELhB,0CAFK;AAGLC;AAHK,OAAP;AAKD;AACF,GA7EM,CAAP;AA8ED;;AAED,SAASyB,UAAT,CAAoBlC,YAApB,SAAwE;AAAA,MAArCmC,QAAqC,SAArCA,QAAqC;AAAA,MAA3BlC,OAA2B,SAA3BA,OAA2B;AAAA,MAAlBC,eAAkB,SAAlBA,eAAkB;;AACtE,SAAO,sBAAY,UAACG,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAI6B,QAAJ,EAAc;AACZ,aAAO1C,WAAW,EAACO,0BAAD,EAAeC,gBAAf,EAAwBC,gCAAxB,EAAX,EACJuB,IADI,CACC;AAAA,eAAOpB,QAAQ+B,GAAR,CAAP;AAAA,OADD,EAEJH,KAFI,CAEE;AAAA,eAAO3B,OAAO8B,GAAP,CAAP;AAAA,OAFF,CAAP;AAGD,KAJD,MAIO;AACL;AACA;AACE;AACH;AACF,GAVM,CAAP;AAWD;;kBAEcF,U","file":"verify-auth.js","sourceRoot":"/home/vagrant/projects/instrumental","sourcesContent":["import fetch from \"isomorphic-fetch\";\r\nimport cookie from \"cookie\";\r\nimport getRedirectInfo from \"../utils/parse-url\";\r\nimport * as C from \"../utils/constants\";\r\nimport { addAuthorizationHeader } from \"../utils/fetch\";\r\nimport parseEndpointConfig from \"./parse-endpoint-config\";\r\nimport url from \"url\";\r\n\r\nfunction parseHeaders (headers) {\r\n  // set header for each key in `tokenFormat` config\r\n  var newHeaders = {};\r\n\r\n  // set flag to ensure that we don't accidentally nuke the headers\r\n  // if the response tokens aren't sent back from the API\r\n  var blankHeaders = true;\r\n\r\n  // set header key + val for each key in `tokenFormat` config\r\n  // TODO: get actual config value\r\n  for (var key of [\"access-token\", \"token-type\", \"client\", \"expiry\", \"uid\", \"config\", \"endpointKey\"]) {\r\n    newHeaders[key] = headers[key];\r\n\r\n    if (newHeaders[key]) {\r\n      // normalize -- sometimes headers come back in array form\r\n      if (typeof newHeaders[key] === \"object\") {\r\n        newHeaders[key] = newHeaders[key][0];\r\n      }\r\n\r\n      blankHeaders = false;\r\n    }\r\n  }\r\n\r\n  // persist headers for next request\r\n  if (!blankHeaders) {\r\n    return newHeaders;\r\n  }\r\n}\r\n\r\n\r\nexport function fetchToken({rawEndpoints, cookies, currentLocation}) {\r\n  let {authRedirectHeaders} = getRedirectInfo(url.parse(currentLocation));\r\n\r\n  return new Promise((resolve, reject) => {\r\n    if (cookies || authRedirectHeaders) {\r\n      let rawCookies = cookie.parse(cookies || \"{}\");\r\n      let parsedCookies = JSON.parse(rawCookies.authHeaders || \"false\");\r\n      let firstTimeLogin,\r\n          mustResetPassword,\r\n          currentEndpointKey,\r\n          headers;\r\n\r\n      if (authRedirectHeaders && authRedirectHeaders.uid && authRedirectHeaders[\"access-token\"]) {\r\n        headers            = parseHeaders(authRedirectHeaders);\r\n        currentEndpointKey = authRedirectHeaders.endpointKey || null;\r\n        mustResetPassword  = JSON.parse(authRedirectHeaders.reset_password || \"false\");\r\n        firstTimeLogin     = JSON.parse(authRedirectHeaders.account_confirmation_success || \"false\");\r\n      } else if (rawCookies && parsedCookies) {\r\n        headers            = parsedCookies;\r\n        currentEndpointKey = JSON.parse(rawCookies[C.SAVED_CONFIG_KEY] || \"null\");\r\n        mustResetPassword  = JSON.parse(parsedCookies.mustResetPassword || \"false\");\r\n        firstTimeLogin     = JSON.parse(parsedCookies.firstTimeLogin || \"false\");\r\n      }\r\n\r\n      if (!headers) {\r\n        return reject({\r\n          reason: \"No creds\",\r\n          currentEndpoint,\r\n          defaultEndpointKey\r\n        });\r\n      }\r\n\r\n      var newHeaders,\r\n          {currentEndpoint, defaultEndpointKey} = parseEndpointConfig(rawEndpoints),\r\n          {apiUrl, tokenValidationPath} = currentEndpoint[currentEndpointKey || defaultEndpointKey],\r\n          validationUrl = `${apiUrl}${tokenValidationPath}?unbatch=true`;\r\n\r\n      return fetch(validationUrl, {\r\n        headers: addAuthorizationHeader(headers['access-token'], headers)\r\n      }).then((resp) => {\r\n        newHeaders = parseHeaders(resp.headers.raw());\r\n        return resp.json();\r\n      })\r\n      .then((json) => {\r\n        if (json.success) {\r\n          return resolve({\r\n            headers: newHeaders,\r\n            user: json.data,\r\n            mustResetPassword,\r\n            firstTimeLogin,\r\n            currentEndpoint,\r\n            currentEndpointKey,\r\n            defaultEndpointKey\r\n          });\r\n        } else {\r\n          return reject({\r\n            reason: json.errors,\r\n            mustResetPassword,\r\n            firstTimeLogin,\r\n            currentEndpoint,\r\n            defaultEndpointKey\r\n          });\r\n        }\r\n      }).catch(reason => {\r\n        return reject({\r\n          reason,\r\n          firstTimeLogin,\r\n          mustResetPassword,\r\n          currentEndpoint,\r\n          defaultEndpointKey\r\n        });\r\n      });\r\n    } else {\r\n      let {currentEndpoint, defaultEndpointKey} = parseEndpointConfig(rawEndpoints);\r\n      reject({\r\n        reason: \"No creds\",\r\n        currentEndpoint,\r\n        defaultEndpointKey\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nfunction verifyAuth(rawEndpoints, {isServer, cookies, currentLocation}) {\r\n  return new Promise((resolve, reject) => {\r\n    if (isServer) {\r\n      return fetchToken({rawEndpoints, cookies, currentLocation})\r\n        .then(res => resolve(res))\r\n        .catch(res => reject(res));\r\n    } else {\r\n      // TODO: deal with localStorage\r\n      //Auth.validateToken(getCurrentEndpointKey())\r\n        //.then((user) => resolve(user.data), (err) => reject({reason: err}));\r\n    }\r\n  });\r\n}\r\n\r\nexport default verifyAuth;\r\n"]}