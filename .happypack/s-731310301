"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _iterator2 = require("babel-runtime/core-js/symbol/iterator");

var _iterator3 = _interopRequireDefault(_iterator2);

exports.fetchToken = fetchToken;

var _isomorphicFetch = require("isomorphic-fetch");

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _cookie = require("cookie");

var _cookie2 = _interopRequireDefault(_cookie);

var _parseUrl = require("../utils/parse-url");

var _parseUrl2 = _interopRequireDefault(_parseUrl);

var _constants = require("../utils/constants");

var C = _interopRequireWildcard(_constants);

var _fetch = require("../utils/fetch");

var _parseEndpointConfig3 = require("./parse-endpoint-config");

var _parseEndpointConfig4 = _interopRequireDefault(_parseEndpointConfig3);

var _url = require("url");

var _url2 = _interopRequireDefault(_url);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseHeaders(headers) {
  // set header for each key in `tokenFormat` config
  var newHeaders = {};

  // set flag to ensure that we don't accidentally nuke the headers
  // if the response tokens aren't sent back from the API
  var blankHeaders = true;

  // set header key + val for each key in `tokenFormat` config
  // TODO: get actual config value
  _ref = ["access-token", "token-type", "client", "expiry", "uid", "config", "endpointKey"];

  if (!(_ref && (typeof _ref[_iterator3.default] === 'function' || Array.isArray(_ref)))) {
    throw new TypeError("Expected _ref to be iterable, got " + _inspect(_ref));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(_ref), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref;

      var key = _step.value;

      newHeaders[key] = headers[key];

      if (newHeaders[key]) {
        // normalize -- sometimes headers come back in array form
        if ((0, _typeof3.default)(newHeaders[key]) === "object") {
          newHeaders[key] = newHeaders[key][0];
        }

        blankHeaders = false;
      }
    }

    // persist headers for next request
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!blankHeaders) {
    return newHeaders;
  }
}

function fetchToken(_ref2) {
  var rawEndpoints = _ref2.rawEndpoints,
      cookies = _ref2.cookies,
      currentLocation = _ref2.currentLocation;

  var _getRedirectInfo = (0, _parseUrl2.default)(_url2.default.parse(currentLocation)),
      authRedirectHeaders = _getRedirectInfo.authRedirectHeaders;

  return new _promise2.default(function (resolve, reject) {
    if (cookies || authRedirectHeaders) {
      var newHeaders, validationUrl, currentEndpoint, defaultEndpointKey, apiUrl, tokenValidationPath;

      var _ret = function () {
        var rawCookies = _cookie2.default.parse(cookies || "{}");
        var parsedCookies = JSON.parse(rawCookies.authHeaders || "false");
        var firstTimeLogin = void 0,
            mustResetPassword = void 0,
            currentEndpointKey = void 0,
            headers = void 0;

        if (authRedirectHeaders && authRedirectHeaders.uid && authRedirectHeaders["access-token"]) {
          headers = parseHeaders(authRedirectHeaders);
          currentEndpointKey = authRedirectHeaders.endpointKey || null;
          mustResetPassword = JSON.parse(authRedirectHeaders.reset_password || "false");
          firstTimeLogin = JSON.parse(authRedirectHeaders.account_confirmation_success || "false");
        } else if (rawCookies && parsedCookies) {
          headers = parsedCookies;
          currentEndpointKey = JSON.parse(rawCookies[C.SAVED_CONFIG_KEY] || "null");
          mustResetPassword = JSON.parse(parsedCookies.mustResetPassword || "false");
          firstTimeLogin = JSON.parse(parsedCookies.firstTimeLogin || "false");
        }

        if (!headers) {
          return {
            v: reject({
              reason: "No creds",
              currentEndpoint: currentEndpoint,
              defaultEndpointKey: defaultEndpointKey
            })
          };
        }

        var _parseEndpointConfig = (0, _parseEndpointConfig4.default)(rawEndpoints);

        currentEndpoint = _parseEndpointConfig.currentEndpoint;
        defaultEndpointKey = _parseEndpointConfig.defaultEndpointKey;
        var _currentEndpoint = currentEndpoint[currentEndpointKey || defaultEndpointKey];
        apiUrl = _currentEndpoint.apiUrl;
        tokenValidationPath = _currentEndpoint.tokenValidationPath;
        validationUrl = "" + apiUrl + tokenValidationPath + "?unbatch=true";


        return {
          v: (0, _isomorphicFetch2.default)(validationUrl, {
            headers: (0, _fetch.addAuthorizationHeader)(headers['access-token'], headers)
          }).then(function (resp) {
            newHeaders = parseHeaders(resp.headers.raw());
            return resp.json();
          }).then(function (json) {
            if (json.success) {
              return resolve({
                headers: newHeaders,
                user: json.data,
                mustResetPassword: mustResetPassword,
                firstTimeLogin: firstTimeLogin,
                currentEndpoint: currentEndpoint,
                currentEndpointKey: currentEndpointKey,
                defaultEndpointKey: defaultEndpointKey
              });
            } else {
              return reject({
                reason: json.errors,
                mustResetPassword: mustResetPassword,
                firstTimeLogin: firstTimeLogin,
                currentEndpoint: currentEndpoint,
                defaultEndpointKey: defaultEndpointKey
              });
            }
          }).catch(function (reason) {
            return reject({
              reason: reason,
              firstTimeLogin: firstTimeLogin,
              mustResetPassword: mustResetPassword,
              currentEndpoint: currentEndpoint,
              defaultEndpointKey: defaultEndpointKey
            });
          })
        };
      }();

      if ((typeof _ret === "undefined" ? "undefined" : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
    } else {
      var _parseEndpointConfig2 = (0, _parseEndpointConfig4.default)(rawEndpoints),
          _currentEndpoint2 = _parseEndpointConfig2.currentEndpoint,
          _defaultEndpointKey = _parseEndpointConfig2.defaultEndpointKey;

      reject({
        reason: "No creds",
        currentEndpoint: _currentEndpoint2,
        defaultEndpointKey: _defaultEndpointKey
      });
    }
  });
}

function verifyAuth(rawEndpoints, _ref3) {
  var isServer = _ref3.isServer,
      cookies = _ref3.cookies,
      currentLocation = _ref3.currentLocation;

  return new _promise2.default(function (resolve, reject) {
    if (isServer) {
      return fetchToken({ rawEndpoints: rawEndpoints, cookies: cookies, currentLocation: currentLocation }).then(function (res) {
        return resolve(res);
      }).catch(function (res) {
        return reject(res);
      });
    } else {
      // TODO: deal with localStorage
      //Auth.validateToken(getCurrentEndpointKey())
      //.then((user) => resolve(user.data), (err) => reject({reason: err}));
    }
  });
}

exports.default = verifyAuth;

function _inspect(input, depth) {
  var maxDepth = 4;
  var maxKeys = 15;

  if (depth === undefined) {
    depth = 0;
  }

  depth += 1;

  if (input === null) {
    return 'null';
  } else if (input === undefined) {
    return 'void';
  } else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
    return typeof input === "undefined" ? "undefined" : (0, _typeof3.default)(input);
  } else if (Array.isArray(input)) {
    if (input.length > 0) {
      var _ret2 = function () {
        if (depth > maxDepth) return {
            v: '[...]'
          };

        var first = _inspect(input[0], depth);

        if (input.every(function (item) {
          return _inspect(item, depth) === first;
        })) {
          return {
            v: first.trim() + '[]'
          };
        } else {
          return {
            v: '[' + input.slice(0, maxKeys).map(function (item) {
              return _inspect(item, depth);
            }).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']'
          };
        }
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : (0, _typeof3.default)(_ret2)) === "object") return _ret2.v;
    } else {
      return 'Array';
    }
  } else {
    var keys = (0, _keys2.default)(input);

    if (!keys.length) {
      if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
        return input.constructor.name;
      } else {
        return 'Object';
      }
    }

    if (depth > maxDepth) return '{...}';
    var indent = '  '.repeat(depth - 1);
    var entries = keys.slice(0, maxKeys).map(function (key) {
      return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : (0, _stringify2.default)(key)) + ': ' + _inspect(input[key], depth) + ';';
    }).join('\n  ' + indent);

    if (keys.length >= maxKeys) {
      entries += '\n  ' + indent + '...';
    }

    if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
      return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
    } else {
      return '{\n  ' + indent + entries + '\n' + indent + '}';
    }
  }
}