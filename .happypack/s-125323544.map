{"version":3,"sources":["src/store/auth/actions/configure.js"],"names":["setEndpointKeys","storeCurrentEndpointKey","configure","C","SET_ENDPOINT_KEYS","STORE_CURRENT_ENDPOINT_KEY","endpoints","currentEndpointKey","defaultEndpointKey","type","endpoint","settings","currentLocation","match","resolve","blank","dispatch","promise","firstTimeLogin","mustResetPassword","user","headers","isServer","then","currentEndpoint","catch","reason","reject","tokenBridge","document","getElementById","rawServerCreds","innerHTML","serverCreds","JSON","parse","initialCredentials","window","location","authRedirectPath","authRedirectHeaders","pathname","uid","clientOnly","cleanSession"],"mappings":"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","file":"configure.js","sourceRoot":"/home/vagrant/projects/instrumental","sourcesContent":["import extend from \"extend\";\nimport * as C from \"../utils/constants\";\nimport {\n  authenticateStart,\n  authenticateComplete,\n  authenticateError\n} from \"./authenticate\";\nimport {\n  showFirstTimeLoginSuccessModal,\n  showFirstTimeLoginErrorModal,\n  showPasswordResetSuccessModal,\n  showPasswordResetErrorModal\n} from \"./ui\";\nimport {ssAuthTokenUpdate} from \"./server\";\nimport {applyConfig} from \"../utils/client-settings\";\nimport {destroySession} from \"../utils/session-storage\";\nimport verifyAuth from \"../utils/verify-auth\";\nimport getRedirectInfo from \"../utils/parse-url\";\nimport {push} from \"react-router-redux\";\n\nexport const SET_ENDPOINT_KEYS = \"SET_ENDPOINT_KEYS\";\nexport const STORE_CURRENT_ENDPOINT_KEY = \"STORE_CURRENT_ENDPOINT_KEY\";\nexport function setEndpointKeys(endpoints, currentEndpointKey, defaultEndpointKey) {\n  return { type: SET_ENDPOINT_KEYS, endpoints, currentEndpointKey, defaultEndpointKey };\n};\nexport function storeCurrentEndpointKey(currentEndpointKey) {\n  return { type: STORE_CURRENT_ENDPOINT_KEY, currentEndpointKey };\n};\n\nexport function configure(endpoint={}, settings={}) {\n  return dispatch => {\n\n    // don't render anything for OAuth redirects\n    if (settings.currentLocation && settings.currentLocation.match(/blank=true/)) {\n      return Promise.resolve({blank: true});\n    }\n\n    dispatch(authenticateStart());\n\n    let promise,\n        firstTimeLogin,\n        mustResetPassword,\n        user,\n        headers;\n\n    if (settings.isServer) {\n      promise = verifyAuth(endpoint, settings)\n        .then(({\n          user,\n          headers,\n          firstTimeLogin,\n          mustResetPassword,\n          currentEndpoint,\n          currentEndpointKey,\n          defaultEndpointKey\n        }) => {\n          dispatch(ssAuthTokenUpdate({\n            headers,\n            user,\n            firstTimeLogin,\n            mustResetPassword\n          }));\n\n          dispatch(setEndpointKeys(Object.keys(currentEndpoint), currentEndpointKey, defaultEndpointKey));\n\n          return user;\n        }).catch(({\n          reason,\n          firstTimeLogin,\n          mustResetPassword,\n          currentEndpoint,\n          defaultEndpointKey\n        }) => {\n          dispatch(ssAuthTokenUpdate({firstTimeLogin, mustResetPassword}));\n          dispatch(setEndpointKeys(Object.keys(currentEndpoint || {}), null, defaultEndpointKey));\n          return Promise.reject({reason});\n        });\n    } else {\n      // if the authentication happened server-side, find the resulting auth\n      // credentials that were injected into the dom.\n      let tokenBridge = document.getElementById(\"token-bridge\");\n\n      if (tokenBridge) {\n        let rawServerCreds = tokenBridge.innerHTML;\n        if (rawServerCreds) {\n          let serverCreds = JSON.parse(rawServerCreds);\n\n          ({headers, user, firstTimeLogin, mustResetPassword} = serverCreds);\n\n          if (user) {\n            dispatch(authenticateComplete(user));\n\n            // do NOT send initial validation request.\n            // instead use the credentials that were sent back by the server.\n            settings.initialCredentials = serverCreds;\n          }\n\n          // sync client dom to prevent React \"out of sync\" error\n          dispatch(ssAuthTokenUpdate({\n            user,\n            headers,\n            mustResetPassword,\n            firstTimeLogin\n          }));\n        }\n      }\n\n\n      let {authRedirectPath, authRedirectHeaders} = getRedirectInfo(window.location);\n\n      if (authRedirectPath) {\n        dispatch(push({pathname: authRedirectPath}));\n      }\n\n      if (authRedirectHeaders && authRedirectHeaders.uid && authRedirectHeaders[\"access-token\"]) {\n        settings.initialCredentials = extend({}, settings.initialCredentials, authRedirectHeaders);\n      }\n\n      // if tokens were invalidated by server or from the settings, make sure\n      // to clear browser credentials\n      if (!settings.clientOnly && !settings.initialCredentials || settings.cleanSession) {\n        destroySession();\n      }\n\n      promise = Promise.resolve(applyConfig({dispatch, endpoint, settings}));\n    }\n\n    return promise\n      .then(user => {\n        dispatch(authenticateComplete(user));\n\n        if (firstTimeLogin) {\n          dispatch(showFirstTimeLoginSuccessModal());\n        }\n\n        if (mustResetPassword) {\n          dispatch(showPasswordResetSuccessModal());\n        }\n\n        return user;\n      })\n      .catch(({reason} = {}) => {\n        dispatch(authenticateError([reason]));\n\n        if (firstTimeLogin) {\n          dispatch(showFirstTimeLoginErrorModal());\n        }\n\n        if (mustResetPassword) {\n          dispatch(showPasswordResetErrorModal());\n        }\n\n        return Promise.resolve({reason});\n      });\n  };\n}\n"]}