{"version":3,"sources":["src/redux-orm/memoize.js"],"names":["eqCheck","memoize","a","b","shouldRun","invalidatorMap","state","some","invalidate","func","equalityCheck","orm","lastOrmState","lastResult","lastArgs","modelNameToInvalidatorMap","args","dbState","otherArgs","dbIsEqual","argsAreEqual","every","value","index","session","newArgs","result","accessedModels","forEach","hasOwnProperty","modelName","nextState"],"mappings":";;;;;;;;;;QAEgBA,O,GAAAA,O;QA8CAC,O,GAAAA,O;;AAhDhB;;;;;;AAEO,SAASD,OAAT,CAAiBE,CAAjB,EAAoBC,CAApB,EAAuB;AAC1B,WAAOD,MAAMC,CAAb;AACH;;AAED,SAASC,SAAT,CAAmBC,cAAnB,EAAmCC,KAAnC,EAA0C;AACtC,WAAO,sBAAOD,cAAP,EAAuBE,IAAvB,CAA4B;AAAA,eAAcC,WAAWF,KAAX,CAAd;AAAA,KAA5B,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCO,SAASL,OAAT,CAAiBQ,IAAjB,EAAqD;AAAA,QAA9BC,aAA8B,uEAAdV,OAAc;AAAA,QAALW,GAAK;;AACxD,QAAIC,eAAe,IAAnB;AACA,QAAIC,aAAa,IAAjB;AACA,QAAIC,WAAW,IAAf;AACA,QAAMC,4BAA4B,EAAlC;;AAEA,WAAO,YAAa;AAAA,0CAATC,IAAS;AAATA,gBAAS;AAAA;;AAAA,YACTC,OADS,GACgBD,IADhB;AAAA,YACGE,SADH,GACgBF,IADhB;;;AAGhB,YAAMG,YAAYP,iBAAiBK,OAAjB,IACC,CAACb,UAAUW,yBAAV,EAAqCE,OAArC,CADpB;;AAGA,YAAMG,eAAeN,YAAYI,UAAUG,KAAV,CAC7B,UAACC,KAAD,EAAQC,KAAR;AAAA,mBAAkBb,cAAcY,KAAd,EAAqBR,SAASS,KAAT,CAArB,CAAlB;AAAA,SAD6B,CAAjC;;AAIA,YAAIJ,aAAaC,YAAjB,EAA+B;AAC3B,mBAAOP,UAAP;AACH;;AAED,YAAMW,UAAUb,IAAIa,OAAJ,CAAYP,OAAZ,CAAhB;AACA,YAAMQ,WAAWD,OAAX,0CAAuBN,SAAvB,EAAN;AACA,YAAMQ,SAASjB,uDAAQgB,OAAR,EAAf;;AAEA;AACA;AACA;AACA;AACAD,gBAAQG,cAAR,CAAuBC,OAAvB,CAA+B,qBAAa;AACxC,gBAAI,CAACb,0BAA0Bc,cAA1B,CAAyCC,SAAzC,CAAL,EAA0D;AACtDf,0CAA0Be,SAA1B,IAAuC;AAAA,2BACnClB,aAAakB,SAAb,MAA4BC,UAAUD,SAAV,CADO;AAAA,iBAAvC;AAEH;AACJ,SALD;;AAOAjB,qBAAaa,MAAb;AACAd,uBAAeK,OAAf;AACAH,mBAAWI,SAAX;;AAEA,eAAOL,UAAP;AACH,KAlCD;AAmCH","file":"memoize.js","sourceRoot":"/home/vagrant/projects/instrumental","sourcesContent":["import values from 'lodash/values';\n\nexport function eqCheck(a, b) {\n    return a === b;\n}\n\nfunction shouldRun(invalidatorMap, state) {\n    return values(invalidatorMap).some(invalidate => invalidate(state));\n}\n\n/**\n * A memoizer to use with redux-orm\n * selectors. When the memoized function is first run,\n * the memoizer will remember the models that are accessed\n * during that function run.\n *\n * On subsequent runs, the memoizer will check if those\n * models' states have changed compared to the previous run.\n *\n * Memoization algorithm operates like this:\n *\n * 1. Has the selector been run before? If not, go to 5.\n *\n * 2. If the selector has other input selectors in addition to the\n *    ORM state selector, check their results for equality with the previous results.\n *    If they aren't equal, go to 5.\n *\n * 3. Is the ORM state referentially equal to the previous ORM state the selector\n *    was called with? If yes, return the previous result.\n *\n * 4. Check which Model's states the selector has accessed on previous runs.\n *    Check for equality with each of those states versus their states in the\n *    previous ORM state. If all of them are equal, return the previous result.\n *\n * 5. Run the selector. Check the Session object used by the selector for\n *    which Model's states were accessed, and merge them with the previously\n *    saved information about accessed models (if-else branching can change\n *    which models are accessed on different inputs). Save the ORM state and\n *    other arguments the selector was called with, overriding previously\n *    saved values. Save the selector result. Return the selector result.\n *\n * @private\n * @param  {Function} func - function to memoize\n * @param  {Function} equalityCheck - equality check function to use with normal\n *                                  selector args\n * @param  {ORM} orm - a redux-orm ORM instance\n * @return {Function} `func` memoized.\n */\nexport function memoize(func, equalityCheck = eqCheck, orm) {\n    let lastOrmState = null;\n    let lastResult = null;\n    let lastArgs = null;\n    const modelNameToInvalidatorMap = {};\n\n    return (...args) => {\n        const [dbState, ...otherArgs] = args;\n\n        const dbIsEqual = lastOrmState === dbState ||\n                           !shouldRun(modelNameToInvalidatorMap, dbState);\n\n        const argsAreEqual = lastArgs && otherArgs.every(\n            (value, index) => equalityCheck(value, lastArgs[index])\n        );\n\n        if (dbIsEqual && argsAreEqual) {\n            return lastResult;\n        }\n\n        const session = orm.session(dbState);\n        const newArgs = [session, ...otherArgs];\n        const result = func(...newArgs);\n\n        // If a selector has control flow branching, different\n        // input arguments might result in a different set of\n        // accessed models. On each run, we check if any new\n        // models are accessed and add their invalidator functions.\n        session.accessedModels.forEach(modelName => {\n            if (!modelNameToInvalidatorMap.hasOwnProperty(modelName)) {\n                modelNameToInvalidatorMap[modelName] = nextState =>\n                    lastOrmState[modelName] !== nextState[modelName];\n            }\n        });\n\n        lastResult = result;\n        lastOrmState = dbState;\n        lastArgs = otherArgs;\n\n        return lastResult;\n    };\n}\n"]}