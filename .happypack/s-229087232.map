{"version":3,"sources":["src/redux-orm/fields.js"],"names":["attr","fk","many","oneToOne","Attribute","opts","hasOwnProperty","getDefault","model","fieldName","orm","prototype","RelationalField","length","toModelName","to","relatedName","through","constructor","ForeignKey","toModel","get","modelName","backwardsFieldName","backwardsDescriptor","errorMsg","Error","ThisField","getClass","virtualFields","ManyToMany","throughModelName","throughModel","throughFields","toFieldName","fields","field","fromFieldName","from","fieldAName","fieldBName","fieldA","OneToOne","toLowerCase","args"],"mappings":"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","file":"fields.js","sourceRoot":"/home/vagrant/projects/instrumental","sourcesContent":["import findKey from 'lodash/findKey';\n\nimport {\n    attrDescriptor,\n    forwardManyToOneDescriptor,\n    backwardManyToOneDescriptor,\n    forwardOneToOneDescriptor,\n    backwardOneToOneDescriptor,\n    manyToManyDescriptor,\n} from './descriptors';\n\nimport {\n    m2mName,\n    reverseFieldName,\n    reverseFieldErrorMessage,\n} from './utils';\n\n/**\n * @module fields\n */\n\n\nexport const Attribute = class Attribute {\n    constructor(opts) {\n        this.opts = (opts || {});\n\n        if (this.opts.hasOwnProperty('getDefault')) {\n            this.getDefault = this.opts.getDefault;\n        }\n    }\n\n    install(model, fieldName, orm) {\n        Object.defineProperty(\n            model.prototype,\n            fieldName,\n            attrDescriptor(fieldName)\n        );\n    }\n};\n\nconst RelationalField = class RelationalField {\n    constructor(...args) {\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const opts = args[0];\n            this.toModelName = opts.to;\n            this.relatedName = opts.relatedName;\n            this.through = opts.through;\n        } else {\n            this.toModelName = args[0];\n            this.relatedName = args[1];\n        }\n    }\n\n    getClass() {\n        return this.constructor;\n    }\n};\n\nexport const ForeignKey = class ForeignKey extends RelationalField {\n    install(model, fieldName, orm) {\n        const toModelName = this.toModelName;\n        const toModel = toModelName === 'this' ? model : orm.get(toModelName);\n\n        // Forwards.\n        Object.defineProperty(\n            model.prototype,\n            fieldName,\n            forwardManyToOneDescriptor(fieldName, toModel.modelName)\n        );\n\n        // Backwards.\n        const backwardsFieldName = this.relatedName\n            ? this.relatedName\n            : reverseFieldName(model.modelName);\n\n        const backwardsDescriptor = Object.getOwnPropertyDescriptor(\n            toModel.prototype,\n            backwardsFieldName\n        );\n\n        if (backwardsDescriptor) {\n            const errorMsg = reverseFieldErrorMessage(\n                model.modelName,\n                fieldName,\n                toModel.modelName,\n                backwardsFieldName\n            );\n            throw new Error(errorMsg);\n        }\n\n        Object.defineProperty(\n            toModel.prototype,\n            backwardsFieldName,\n            backwardManyToOneDescriptor(fieldName, model.modelName)\n        );\n\n        const ThisField = this.getClass();\n        toModel.virtualFields[backwardsFieldName] = new ThisField(model.modelName, fieldName);\n    }\n};\n\n\nexport const ManyToMany = class ManyToMany extends RelationalField {\n    install(model, fieldName, orm) {\n        const toModelName = this.toModelName;\n        const toModel = toModelName === 'this' ? model : orm.get(toModelName);\n\n        // Forwards.\n\n        const throughModelName =\n            this.through ||\n            m2mName(model.modelName, fieldName);\n\n        const throughModel = orm.get(throughModelName);\n\n        let throughFields;\n        if (!this.throughFields) {\n            const toFieldName = findKey(\n                throughModel.fields,\n                field =>\n                    field instanceof ForeignKey &&\n                    field.toModelName === toModel.modelName\n            );\n            const fromFieldName = findKey(\n                throughModel.fields,\n                field =>\n                    field instanceof ForeignKey &&\n                    field.toModelName === model.modelName\n            );\n            throughFields = {\n                to: toFieldName,\n                from: fromFieldName,\n            };\n        } else {\n            const [fieldAName, fieldBName] = throughFields;\n            const fieldA = throughModel.fields[fieldAName];\n            if (fieldA.toModelName === toModel.modelName) {\n                throughFields = {\n                    to: fieldAName,\n                    from: fieldBName,\n                };\n            } else {\n                throughFields = {\n                    to: fieldBName,\n                    from: fieldAName,\n                };\n            }\n        }\n\n        Object.defineProperty(\n            model.prototype,\n            fieldName,\n            manyToManyDescriptor(\n                model.modelName,\n                toModel.modelName,\n                throughModelName,\n                throughFields,\n                false\n            )\n        );\n\n        model.virtualFields[fieldName] = new ManyToMany({\n            to: toModel.modelName,\n            relatedName: fieldName,\n            through: this.through,\n        });\n\n        // Backwards.\n        const backwardsFieldName = this.relatedName\n            ? this.relatedName\n            : reverseFieldName(model.modelName);\n\n        const backwardsDescriptor = Object.getOwnPropertyDescriptor(\n            toModel.prototype,\n            backwardsFieldName\n        );\n\n        if (backwardsDescriptor) {\n            // Backwards field was already defined on toModel.\n            const errorMsg = reverseFieldErrorMessage(\n                model.modelName,\n                fieldName,\n                toModel.modelName,\n                backwardsFieldName\n            );\n            throw new Error(errorMsg);\n        }\n\n        Object.defineProperty(\n            toModel.prototype,\n            backwardsFieldName,\n            manyToManyDescriptor(\n                model.modelName,\n                toModel.modelName,\n                throughModelName,\n                throughFields,\n                true\n            )\n        );\n        toModel.virtualFields[backwardsFieldName] = new ManyToMany({\n            to: model.modelName,\n            relatedName: fieldName,\n            through: throughModelName,\n        });\n    }\n\n    getDefault() {\n        return [];\n    }\n};\n\n\nexport const OneToOne = class OneToOne extends RelationalField {\n    install(model, fieldName, orm) {\n        const toModelName = this.toModelName;\n        const toModel = toModelName === 'this' ? model : orm.get(toModelName);\n\n        // Forwards.\n        Object.defineProperty(\n            model.prototype,\n            fieldName,\n            forwardOneToOneDescriptor(fieldName, toModel.modelName)\n        );\n\n        // Backwards.\n        const backwardsFieldName = this.relatedName\n            ? this.relatedName\n            : model.modelName.toLowerCase();\n\n        const backwardsDescriptor = Object.getOwnPropertyDescriptor(\n            toModel.prototype,\n            backwardsFieldName\n        );\n\n        if (backwardsDescriptor) {\n            const errorMsg = reverseFieldErrorMessage(\n                model.modelName,\n                fieldName,\n                toModel.modelName,\n                backwardsFieldName\n            );\n            throw new Error(errorMsg);\n        }\n\n        Object.defineProperty(\n            toModel.prototype,\n            backwardsFieldName,\n            backwardOneToOneDescriptor(fieldName, model.modelName)\n        );\n        toModel.virtualFields[backwardsFieldName] = new OneToOne(model.modelName, fieldName);\n    }\n};\n\n/**\n * Defines a value attribute on the model.\n * Though not required, it is recommended to define this for each non-foreign key you wish to use.\n * Getters and setters need to be defined on each Model\n * instantiation for undeclared data fields, which is slower.\n * You can use the optional `getDefault` parameter to fill in unpassed values\n * to {@link Model#create}, such as for generating ID's with UUID:\n *\n * ```javascript\n * import getUUID from 'your-uuid-package-of-choice';\n *\n * fields = {\n *   id: attr({ getDefault: () => getUUID() }),\n *   title: attr(),\n * }\n * ```\n *\n * @param  {Object} [opts]\n * @param {Function} [opts.getDefault] - if you give a function here, it's return\n *                                       value from calling with zero arguments will\n *                                       be used as the value when creating a new Model\n *                                       instance with {@link Model#create} if the field\n *                                       value is not passed.\n * @return {Attribute}\n */\nexport function attr(opts) {\n    return new Attribute(opts);\n}\n\n/**\n * Defines a foreign key on a model, which points\n * to a single entity on another model.\n *\n * You can pass arguments as either a single object,\n * or two arguments.\n *\n * If you pass two arguments, the first one is the name\n * of the Model the foreign key is pointing to, and\n * the second one is an optional related name, which will\n * be used to access the Model the foreign key\n * is being defined from, from the target Model.\n *\n * If the related name is not passed, it will be set as\n * `${toModelName}Set`.\n *\n * If you pass an object to `fk`, it has to be in the form\n *\n * ```javascript\n * fields = {\n *   author: fk({ to: 'Author', relatedName: 'books' })\n * }\n * ```\n *\n * Which is equal to\n *\n * ```javascript\n * fields = {\n *   author: fk('Author', 'books'),\n * }\n * ```\n *\n * @param  {string|boolean} toModelNameOrObj - the `modelName` property of\n *                                           the Model that is the target of the\n *                                           foreign key, or an object with properties\n *                                           `to` and optionally `relatedName`.\n * @param {string} [relatedName] - if you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a QuerySet the foreign key is defined from,\n *                                 from the target model.\n * @return {ForeignKey}\n */\nexport function fk(...args) {\n    return new ForeignKey(...args);\n}\n\n/**\n * Defines a many-to-many relationship between\n * this (source) and another (target) model.\n *\n * The relationship is modeled with an extra model called the through model.\n * The through model has foreign keys to both the source and target models.\n *\n * You can define your own through model if you want to associate more information\n * to the relationship. A custom through model must have at least two foreign keys,\n * one pointing to the source Model, and one pointing to the target Model.\n *\n * If you have more than one foreign key pointing to a source or target Model in the\n * through Model, you must pass the option `throughFields`, which is an array of two\n * strings, where the strings are the field names that identify the foreign keys to\n * be used for the many-to-many relationship. Redux-ORM will figure out which field name\n * points to which model by checking the through Model definition.\n *\n * Unlike `fk`, this function accepts only an object argument.\n *\n * ```javascript\n * class Authorship extends Model {}\n * Authorship.modelName = 'Authorship';\n * Authorship.fields = {\n *   author: fk('Author', 'authorships'),\n *   book: fk('Book', 'authorships'),\n * };\n *\n * class Author extends Model {}\n * Author.modelName = 'Author';\n * Author.fields = {\n *   books: many({\n *     to: 'Book',\n *     relatedName: 'authors',\n *     through: 'Authorship',\n *\n *     // this is optional, since Redux-ORM can figure\n *     // out the through fields itself as there aren't\n *     // multiple foreign keys pointing to the same models.\n *     throughFields: ['author', 'book'],\n *   })\n * };\n *\n * class Book extends Model {}\n * Book.modelName = 'Book';\n * ```\n *\n * You should only define the many-to-many relationship on one side. In the\n * above case of Authors to Books through Authorships, the relationship is\n * defined only on the Author model.\n *\n * @param  {Object} options - options\n * @param  {string} options.to - the `modelName` attribute of the target Model.\n * @param  {string} [options.through] - the `modelName` attribute of the through Model which\n *                                    must declare at least one foreign key to both source and\n *                                    target Models. If not supplied, Redux-Orm will autogenerate\n *                                    one.\n * @param  {string[]} [options.throughFields] - this must be supplied only when a custom through\n *                                            Model has more than one foreign key pointing to\n *                                            either the source or target mode. In this case\n *                                            Redux-ORM can't figure out the correct fields for\n *                                            you, you must provide them. The supplied array should\n *                                            have two elements that are the field names for the\n *                                            through fields you want to declare the many-to-many\n *                                            relationship with. The order doesn't matter;\n *                                            Redux-ORM will figure out which field points to\n *                                            the source Model and which to the target Model.\n * @param  {string} [options.relatedName] - the attribute used to access a QuerySet\n *                                          of source Models from target Model.\n * @return {ManyToMany}\n */\nexport function many(...args) {\n    return new ManyToMany(...args);\n}\n\n/**\n * Defines a one-to-one relationship. In database terms, this is a foreign key with the\n * added restriction that only one entity can point to single target entity.\n *\n * The arguments are the same as with `fk`. If `relatedName` is not supplied,\n * the source model name in lowercase will be used. Note that with the one-to-one\n * relationship, the `relatedName` should be in singular, not plural.\n * @param  {string|boolean} toModelNameOrObj - the `modelName` property of\n *                                           the Model that is the target of the\n *                                           foreign key, or an object with properties\n *                                           `to` and optionally `relatedName`.\n * @param {string} [relatedName] - if you didn't pass an object as the first argument,\n *                                 this is the property name that will be used to\n *                                 access a Model the foreign key is defined from,\n *                                 from the target Model.\n * @return {OneToOne}\n */\nexport function oneToOne(...args) {\n    return new OneToOne(...args);\n}\n"]}