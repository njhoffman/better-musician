"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STORE_CURRENT_ENDPOINT_KEY = exports.SET_ENDPOINT_KEYS = undefined;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

exports.setEndpointKeys = setEndpointKeys;
exports.storeCurrentEndpointKey = storeCurrentEndpointKey;
exports.configure = configure;

var _extend = require("extend");

var _extend2 = _interopRequireDefault(_extend);

var _constants = require("../utils/constants");

var C = _interopRequireWildcard(_constants);

var _authenticate = require("./authenticate");

var _ui = require("./ui");

var _server = require("./server");

var _clientSettings = require("../utils/client-settings");

var _sessionStorage = require("../utils/session-storage");

var _verifyAuth = require("../utils/verify-auth");

var _verifyAuth2 = _interopRequireDefault(_verifyAuth);

var _parseUrl = require("../utils/parse-url");

var _parseUrl2 = _interopRequireDefault(_parseUrl);

var _reactRouterRedux = require("react-router-redux");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET_ENDPOINT_KEYS = exports.SET_ENDPOINT_KEYS = "SET_ENDPOINT_KEYS";
var STORE_CURRENT_ENDPOINT_KEY = exports.STORE_CURRENT_ENDPOINT_KEY = "STORE_CURRENT_ENDPOINT_KEY";
function setEndpointKeys(endpoints, currentEndpointKey, defaultEndpointKey) {
  return { type: SET_ENDPOINT_KEYS, endpoints: endpoints, currentEndpointKey: currentEndpointKey, defaultEndpointKey: defaultEndpointKey };
};
function storeCurrentEndpointKey(currentEndpointKey) {
  return { type: STORE_CURRENT_ENDPOINT_KEY, currentEndpointKey: currentEndpointKey };
};

function configure() {
  var endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (dispatch) {

    // don't render anything for OAuth redirects
    if (settings.currentLocation && settings.currentLocation.match(/blank=true/)) {
      return _promise2.default.resolve({ blank: true });
    }

    dispatch((0, _authenticate.authenticateStart)());

    var promise = void 0,
        firstTimeLogin = void 0,
        mustResetPassword = void 0,
        user = void 0,
        headers = void 0;

    if (settings.isServer) {
      promise = (0, _verifyAuth2.default)(endpoint, settings).then(function (_ref) {
        var user = _ref.user,
            headers = _ref.headers,
            firstTimeLogin = _ref.firstTimeLogin,
            mustResetPassword = _ref.mustResetPassword,
            currentEndpoint = _ref.currentEndpoint,
            currentEndpointKey = _ref.currentEndpointKey,
            defaultEndpointKey = _ref.defaultEndpointKey;

        dispatch((0, _server.ssAuthTokenUpdate)({
          headers: headers,
          user: user,
          firstTimeLogin: firstTimeLogin,
          mustResetPassword: mustResetPassword
        }));

        dispatch(setEndpointKeys((0, _keys2.default)(currentEndpoint), currentEndpointKey, defaultEndpointKey));

        return user;
      }).catch(function (_ref2) {
        var reason = _ref2.reason,
            firstTimeLogin = _ref2.firstTimeLogin,
            mustResetPassword = _ref2.mustResetPassword,
            currentEndpoint = _ref2.currentEndpoint,
            defaultEndpointKey = _ref2.defaultEndpointKey;

        dispatch((0, _server.ssAuthTokenUpdate)({ firstTimeLogin: firstTimeLogin, mustResetPassword: mustResetPassword }));
        dispatch(setEndpointKeys((0, _keys2.default)(currentEndpoint || {}), null, defaultEndpointKey));
        return _promise2.default.reject({ reason: reason });
      });
    } else {
      // if the authentication happened server-side, find the resulting auth
      // credentials that were injected into the dom.
      var tokenBridge = document.getElementById("token-bridge");

      if (tokenBridge) {
        var rawServerCreds = tokenBridge.innerHTML;
        if (rawServerCreds) {
          var serverCreds = JSON.parse(rawServerCreds);

          headers = serverCreds.headers;
          user = serverCreds.user;
          firstTimeLogin = serverCreds.firstTimeLogin;
          mustResetPassword = serverCreds.mustResetPassword;


          if (user) {
            dispatch((0, _authenticate.authenticateComplete)(user));

            // do NOT send initial validation request.
            // instead use the credentials that were sent back by the server.
            settings.initialCredentials = serverCreds;
          }

          // sync client dom to prevent React "out of sync" error
          dispatch((0, _server.ssAuthTokenUpdate)({
            user: user,
            headers: headers,
            mustResetPassword: mustResetPassword,
            firstTimeLogin: firstTimeLogin
          }));
        }
      }

      var _getRedirectInfo = (0, _parseUrl2.default)(window.location),
          authRedirectPath = _getRedirectInfo.authRedirectPath,
          authRedirectHeaders = _getRedirectInfo.authRedirectHeaders;

      if (authRedirectPath) {
        dispatch((0, _reactRouterRedux.push)({ pathname: authRedirectPath }));
      }

      if (authRedirectHeaders && authRedirectHeaders.uid && authRedirectHeaders["access-token"]) {
        settings.initialCredentials = (0, _extend2.default)({}, settings.initialCredentials, authRedirectHeaders);
      }

      // if tokens were invalidated by server or from the settings, make sure
      // to clear browser credentials
      if (!settings.clientOnly && !settings.initialCredentials || settings.cleanSession) {
        (0, _sessionStorage.destroySession)();
      }

      promise = _promise2.default.resolve((0, _clientSettings.applyConfig)({ dispatch: dispatch, endpoint: endpoint, settings: settings }));
    }

    return promise.then(function (user) {
      dispatch((0, _authenticate.authenticateComplete)(user));

      if (firstTimeLogin) {
        dispatch((0, _ui.showFirstTimeLoginSuccessModal)());
      }

      if (mustResetPassword) {
        dispatch((0, _ui.showPasswordResetSuccessModal)());
      }

      return user;
    }).catch(function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          reason = _ref3.reason;

      dispatch((0, _authenticate.authenticateError)([reason]));

      if (firstTimeLogin) {
        dispatch((0, _ui.showFirstTimeLoginErrorModal)());
      }

      if (mustResetPassword) {
        dispatch((0, _ui.showPasswordResetErrorModal)());
      }

      return _promise2.default.resolve({ reason: reason });
    });
  };
}