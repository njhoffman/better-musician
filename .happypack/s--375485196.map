{"version":3,"sources":["src/redux-orm/db/Table.js"],"names":["DEFAULT_OPTS","idAttribute","arrName","mapName","idSequencer","_currMax","userPassedId","currMax","newMax","newId","undefined","Math","max","Table","userOpts","branch","id","hasOwnProperty","map","accessId","getMeta","tx","newMaxId","setMeta","clauses","reduce","rows","type","payload","idExists","iteratees","orders","accessList","key","value","batchToken","withMutations","res","mutable","setIn","batch","meta","entry","hasId","workingState","getMaxId","setMaxId","finalEntry","set","push","state","created","nextState","merge","mergeObj","mapFunction","row","newMap","result","arr","idsToDelete","forEach","idx","indexOf","splice","omit","filter"],"mappings":"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","file":"Table.js","sourceRoot":"/home/vagrant/projects/instrumental","sourcesContent":["import reject from 'lodash/reject';\nimport filter from 'lodash/filter';\nimport orderBy from 'lodash/orderBy';\nimport ops from 'immutable-ops';\n\nimport { FILTER, EXCLUDE, ORDER_BY } from '../constants';\nimport { includes } from '../utils';\n\n\nconst DEFAULT_OPTS = {\n    idAttribute: 'id',\n    arrName: 'items',\n    mapName: 'itemsById',\n};\n\n// Input is the current max id and the new id passed to the create action.\n// Both may be undefined. The current max id in the case that this is the first Model\n// being created, and the new id if the id was not explicitly passed to the\n// database.\n//\n// Return value is the new max id and the id to use to create the new row.\n// If the id's are strings, the id must be passed explicitly every time.\n// In this case, the current max id will remain `NaN` due to `Math.max`, but that's fine.\nfunction idSequencer(_currMax, userPassedId) {\n    let currMax = _currMax;\n    let newMax;\n    let newId;\n\n    if (currMax === undefined) {\n        currMax = -1;\n    }\n\n    if (userPassedId === undefined) {\n        newMax = newId = currMax + 1;\n    } else {\n        newMax = Math.max(currMax + 1, userPassedId);\n        newId = userPassedId;\n    }\n\n    return [\n        newMax, // new max id\n        newId, // id to use for row creation\n    ];\n}\n\n/**\n * Handles the underlying data structure for a {@link Model} class.\n */\nconst Table = class Table {\n    /**\n     * Creates a new {@link Table} instance.\n     * @param  {Object} userOpts - options to use.\n     * @param  {string} [userOpts.idAttribute=id] - the id attribute of the entity.\n     * @param  {string} [userOpts.arrName=items] - the state attribute where an array of\n     *                                             entity id's are stored\n     * @param  {string} [userOpts.mapName=itemsById] - the state attribute where the entity objects\n     *                                                 are stored in a id to entity object\n     *                                                 map.\n     */\n    constructor(userOpts) {\n        Object.assign(this, DEFAULT_OPTS, userOpts);\n    }\n\n    /**\n     * Returns a reference to the object at index `id`\n     * in state `branch`.\n     *\n     * @param  {Object} branch - the state\n     * @param  {Number} id - the id of the object to get\n     * @return {Object|undefined} A reference to the raw object in the state or\n     *                            `undefined` if not found.\n     */\n    accessId(branch, id) {\n        return branch[this.mapName][id];\n    }\n\n    idExists(branch, id) {\n        return branch[this.mapName].hasOwnProperty(id);\n    }\n\n    accessIdList(branch) {\n        return branch[this.arrName];\n    }\n\n    accessList(branch) {\n        return branch[this.arrName].map(id => this.accessId(branch, id));\n    }\n\n    getMaxId(branch) {\n        return this.getMeta(branch, 'maxId');\n    }\n\n    setMaxId(tx, branch, newMaxId) {\n        return this.setMeta(tx, branch, 'maxId', newMaxId);\n    }\n\n    nextId(id) {\n        return id + 1;\n    }\n\n    query(branch, clauses) {\n        return clauses.reduce((rows, { type, payload }) => {\n            switch (type) {\n            case FILTER: {\n                if (payload.hasOwnProperty(this.idAttribute) && payload[this.idAttribute]) {\n                    // Payload specified a primary key; Since that is unique, we can directly\n                    // return that.\n                    const id = payload[this.idAttribute];\n                    return this.idExists(branch, id)\n                        ? [this.accessId(branch, payload[this.idAttribute])]\n                        : [];\n                }\n                return filter(rows, payload);\n            }\n            case EXCLUDE: {\n                return reject(rows, payload);\n            }\n            case ORDER_BY: {\n                const [iteratees, orders] = payload;\n                return orderBy(rows, iteratees, orders);\n            }\n            default:\n                return rows;\n            }\n        }, this.accessList(branch));\n    }\n\n    /**\n     * Returns the default state for the data structure.\n     * @return {Object} The default state for this {@link Backend} instance's data structure\n     */\n    getEmptyState() {\n        return {\n            [this.arrName]: [],\n            [this.mapName]: {},\n            meta: {},\n        };\n    }\n\n    setMeta(tx, branch, key, value) {\n        const { batchToken, withMutations } = tx;\n        if (withMutations) {\n            const res = ops.mutable.setIn(['meta', key], value, branch);\n            return res;\n        }\n\n        return ops.batch.setIn(batchToken, ['meta', key], value, branch);\n    }\n\n    getMeta(branch, key) {\n        return branch.meta[key];\n    }\n\n    /**\n     * Returns the data structure including a new object `entry`\n     * @param  {Object} tx - transaction info\n     * @param  {Object} branch - the data structure state\n     * @param  {Object} entry - the object to insert\n     * @return {Object} an object with two keys: `state` and `created`.\n     *                  `state` is the new table state and `created` is the\n     *                  row that was created.\n     */\n    insert(tx, branch, entry) {\n        const { batchToken, withMutations } = tx;\n\n        const hasId = entry.hasOwnProperty(this.idAttribute);\n\n        let workingState = branch;\n\n        // This will not affect string id's.\n        const [newMaxId, id] = idSequencer(this.getMaxId(branch), entry[this.idAttribute]);\n        workingState = this.setMaxId(tx, branch, newMaxId);\n\n        const finalEntry = hasId\n            ? entry\n            : ops.batch.set(batchToken, this.idAttribute, id, entry);\n\n        if (withMutations) {\n            ops.mutable.push(id, workingState[this.arrName]);\n            ops.mutable.set(id, finalEntry, workingState[this.mapName]);\n            return {\n                state: workingState,\n                created: finalEntry,\n            };\n        }\n\n        const nextState = ops.batch.merge(batchToken, {\n            [this.arrName]: ops.batch.push(batchToken, id, workingState[this.arrName]),\n            [this.mapName]: ops.batch.merge(batchToken, { [id]: finalEntry }, workingState[this.mapName]),\n        }, workingState);\n\n        return {\n            state: nextState,\n            created: finalEntry,\n        };\n    }\n\n    /**\n     * Returns the data structure with objects where `rows`\n     * are merged with `mergeObj`.\n     *\n     * @param  {Object} tx - transaction info\n     * @param  {Object} branch - the data structure state\n     * @param  {Object[]} rows - rows to update\n     * @param  {Object} mergeObj - The object to merge with each row.\n     * @return {Object}\n     */\n    update(tx, branch, rows, mergeObj) {\n        const { batchToken, withMutations } = tx;\n\n        const {\n            mapName,\n        } = this;\n\n        const mapFunction = row => {\n            const merge = withMutations ? ops.mutable.merge : ops.batch.merge(batchToken);\n            return merge(mergeObj, row);\n        };\n\n        const set = withMutations ? ops.mutable.set : ops.batch.set(batchToken);\n\n        const newMap = rows.reduce((map, row) => {\n            const result = mapFunction(row);\n            return set(result[this.idAttribute], result, map);\n        }, branch[mapName]);\n        return ops.batch.set(batchToken, mapName, newMap, branch);\n    }\n\n    /**\n     * Returns the data structure without rows `rows`.\n     * @param  {Object} tx - transaction info\n     * @param  {Object} branch - the data structure state\n     * @param  {Object[]} rows - rows to update\n     * @return {Object} the data structure without ids in `idsToDelete`.\n     */\n    delete(tx, branch, rows) {\n        const { batchToken, withMutations } = tx;\n\n        const { arrName, mapName } = this;\n        const arr = branch[arrName];\n\n        const idsToDelete = rows.map(row => row[this.idAttribute]);\n        if (withMutations) {\n            idsToDelete.forEach(id => {\n                const idx = arr.indexOf(id);\n                if (idx !== -1) {\n                    ops.mutable.splice(idx, 1, [], arr);\n                }\n\n                ops.mutable.omit(id, branch[mapName]);\n            });\n            return branch;\n        }\n\n        return ops.batch.merge(batchToken, {\n            [arrName]: ops.batch.filter(\n                batchToken,\n                id => !includes(idsToDelete, id),\n                branch[arrName]\n            ),\n            [mapName]: ops.batch.omit(\n                batchToken,\n                idsToDelete,\n                branch[mapName]\n            ),\n        }, branch);\n    }\n};\n\nexport default Table;\n"]}