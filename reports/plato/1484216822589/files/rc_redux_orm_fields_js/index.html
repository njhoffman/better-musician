<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - rc/redux-orm/fields.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>rc/redux-orm/fields.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">422</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.59</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import findKey from &#039;lodash/findKey&#039;;

import {
    attrDescriptor,
    forwardManyToOneDescriptor,
    backwardManyToOneDescriptor,
    forwardOneToOneDescriptor,
    backwardOneToOneDescriptor,
    manyToManyDescriptor,
} from &#039;./descriptors&#039;;

import {
    m2mName,
    reverseFieldName,
    reverseFieldErrorMessage,
} from &#039;./utils&#039;;

/**
 * @module fields
 */


export const Attribute = class Attribute {
    constructor(opts) {
        this.opts = (opts || {});

        if (this.opts.hasOwnProperty(&#039;getDefault&#039;)) {
            this.getDefault = this.opts.getDefault;
        }
    }

    install(model, fieldName, orm) {
        Object.defineProperty(
            model.prototype,
            fieldName,
            attrDescriptor(fieldName)
        );
    }
};

const RelationalField = class RelationalField {
    constructor(...args) {
        if (args.length === 1 &amp;&amp; typeof args[0] === &#039;object&#039;) {
            const opts = args[0];
            this.toModelName = opts.to;
            this.relatedName = opts.relatedName;
            this.through = opts.through;
        } else {
            this.toModelName = args[0];
            this.relatedName = args[1];
        }
    }

    getClass() {
        return this.constructor;
    }
};

export const ForeignKey = class ForeignKey extends RelationalField {
    install(model, fieldName, orm) {
        const toModelName = this.toModelName;
        const toModel = toModelName === &#039;this&#039; ? model : orm.get(toModelName);

        // Forwards.
        Object.defineProperty(
            model.prototype,
            fieldName,
            forwardManyToOneDescriptor(fieldName, toModel.modelName)
        );

        // Backwards.
        const backwardsFieldName = this.relatedName
            ? this.relatedName
            : reverseFieldName(model.modelName);

        const backwardsDescriptor = Object.getOwnPropertyDescriptor(
            toModel.prototype,
            backwardsFieldName
        );

        if (backwardsDescriptor) {
            const errorMsg = reverseFieldErrorMessage(
                model.modelName,
                fieldName,
                toModel.modelName,
                backwardsFieldName
            );
            throw new Error(errorMsg);
        }

        Object.defineProperty(
            toModel.prototype,
            backwardsFieldName,
            backwardManyToOneDescriptor(fieldName, model.modelName)
        );

        const ThisField = this.getClass();
        toModel.virtualFields[backwardsFieldName] = new ThisField(model.modelName, fieldName);
    }
};


export const ManyToMany = class ManyToMany extends RelationalField {
    install(model, fieldName, orm) {
        const toModelName = this.toModelName;
        const toModel = toModelName === &#039;this&#039; ? model : orm.get(toModelName);

        // Forwards.

        const throughModelName =
            this.through ||
            m2mName(model.modelName, fieldName);

        const throughModel = orm.get(throughModelName);

        let throughFields;
        if (!this.throughFields) {
            const toFieldName = findKey(
                throughModel.fields,
                field =&gt;
                    field instanceof ForeignKey &amp;&amp;
                    field.toModelName === toModel.modelName
            );
            const fromFieldName = findKey(
                throughModel.fields,
                field =&gt;
                    field instanceof ForeignKey &amp;&amp;
                    field.toModelName === model.modelName
            );
            throughFields = {
                to: toFieldName,
                from: fromFieldName,
            };
        } else {
            const [fieldAName, fieldBName] = throughFields;
            const fieldA = throughModel.fields[fieldAName];
            if (fieldA.toModelName === toModel.modelName) {
                throughFields = {
                    to: fieldAName,
                    from: fieldBName,
                };
            } else {
                throughFields = {
                    to: fieldBName,
                    from: fieldAName,
                };
            }
        }

        Object.defineProperty(
            model.prototype,
            fieldName,
            manyToManyDescriptor(
                model.modelName,
                toModel.modelName,
                throughModelName,
                throughFields,
                false
            )
        );

        model.virtualFields[fieldName] = new ManyToMany({
            to: toModel.modelName,
            relatedName: fieldName,
            through: this.through,
        });

        // Backwards.
        const backwardsFieldName = this.relatedName
            ? this.relatedName
            : reverseFieldName(model.modelName);

        const backwardsDescriptor = Object.getOwnPropertyDescriptor(
            toModel.prototype,
            backwardsFieldName
        );

        if (backwardsDescriptor) {
            // Backwards field was already defined on toModel.
            const errorMsg = reverseFieldErrorMessage(
                model.modelName,
                fieldName,
                toModel.modelName,
                backwardsFieldName
            );
            throw new Error(errorMsg);
        }

        Object.defineProperty(
            toModel.prototype,
            backwardsFieldName,
            manyToManyDescriptor(
                model.modelName,
                toModel.modelName,
                throughModelName,
                throughFields,
                true
            )
        );
        toModel.virtualFields[backwardsFieldName] = new ManyToMany({
            to: model.modelName,
            relatedName: fieldName,
            through: throughModelName,
        });
    }

    getDefault() {
        return [];
    }
};


export const OneToOne = class OneToOne extends RelationalField {
    install(model, fieldName, orm) {
        const toModelName = this.toModelName;
        const toModel = toModelName === &#039;this&#039; ? model : orm.get(toModelName);

        // Forwards.
        Object.defineProperty(
            model.prototype,
            fieldName,
            forwardOneToOneDescriptor(fieldName, toModel.modelName)
        );

        // Backwards.
        const backwardsFieldName = this.relatedName
            ? this.relatedName
            : model.modelName.toLowerCase();

        const backwardsDescriptor = Object.getOwnPropertyDescriptor(
            toModel.prototype,
            backwardsFieldName
        );

        if (backwardsDescriptor) {
            const errorMsg = reverseFieldErrorMessage(
                model.modelName,
                fieldName,
                toModel.modelName,
                backwardsFieldName
            );
            throw new Error(errorMsg);
        }

        Object.defineProperty(
            toModel.prototype,
            backwardsFieldName,
            backwardOneToOneDescriptor(fieldName, model.modelName)
        );
        toModel.virtualFields[backwardsFieldName] = new OneToOne(model.modelName, fieldName);
    }
};

/**
 * Defines a value attribute on the model.
 * Though not required, it is recommended to define this for each non-foreign key you wish to use.
 * Getters and setters need to be defined on each Model
 * instantiation for undeclared data fields, which is slower.
 * You can use the optional `getDefault` parameter to fill in unpassed values
 * to {@link Model#create}, such as for generating ID&#039;s with UUID:
 *
 * ```javascript
 * import getUUID from &#039;your-uuid-package-of-choice&#039;;
 *
 * fields = {
 *   id: attr({ getDefault: () =&gt; getUUID() }),
 *   title: attr(),
 * }
 * ```
 *
 * @param  {Object} [opts]
 * @param {Function} [opts.getDefault] - if you give a function here, it&#039;s return
 *                                       value from calling with zero arguments will
 *                                       be used as the value when creating a new Model
 *                                       instance with {@link Model#create} if the field
 *                                       value is not passed.
 * @return {Attribute}
 */
export function attr(opts) {
    return new Attribute(opts);
}

/**
 * Defines a foreign key on a model, which points
 * to a single entity on another model.
 *
 * You can pass arguments as either a single object,
 * or two arguments.
 *
 * If you pass two arguments, the first one is the name
 * of the Model the foreign key is pointing to, and
 * the second one is an optional related name, which will
 * be used to access the Model the foreign key
 * is being defined from, from the target Model.
 *
 * If the related name is not passed, it will be set as
 * `${toModelName}Set`.
 *
 * If you pass an object to `fk`, it has to be in the form
 *
 * ```javascript
 * fields = {
 *   author: fk({ to: &#039;Author&#039;, relatedName: &#039;books&#039; })
 * }
 * ```
 *
 * Which is equal to
 *
 * ```javascript
 * fields = {
 *   author: fk(&#039;Author&#039;, &#039;books&#039;),
 * }
 * ```
 *
 * @param  {string|boolean} toModelNameOrObj - the `modelName` property of
 *                                           the Model that is the target of the
 *                                           foreign key, or an object with properties
 *                                           `to` and optionally `relatedName`.
 * @param {string} [relatedName] - if you didn&#039;t pass an object as the first argument,
 *                                 this is the property name that will be used to
 *                                 access a QuerySet the foreign key is defined from,
 *                                 from the target model.
 * @return {ForeignKey}
 */
export function fk(...args) {
    return new ForeignKey(...args);
}

/**
 * Defines a many-to-many relationship between
 * this (source) and another (target) model.
 *
 * The relationship is modeled with an extra model called the through model.
 * The through model has foreign keys to both the source and target models.
 *
 * You can define your own through model if you want to associate more information
 * to the relationship. A custom through model must have at least two foreign keys,
 * one pointing to the source Model, and one pointing to the target Model.
 *
 * If you have more than one foreign key pointing to a source or target Model in the
 * through Model, you must pass the option `throughFields`, which is an array of two
 * strings, where the strings are the field names that identify the foreign keys to
 * be used for the many-to-many relationship. Redux-ORM will figure out which field name
 * points to which model by checking the through Model definition.
 *
 * Unlike `fk`, this function accepts only an object argument.
 *
 * ```javascript
 * class Authorship extends Model {}
 * Authorship.modelName = &#039;Authorship&#039;;
 * Authorship.fields = {
 *   author: fk(&#039;Author&#039;, &#039;authorships&#039;),
 *   book: fk(&#039;Book&#039;, &#039;authorships&#039;),
 * };
 *
 * class Author extends Model {}
 * Author.modelName = &#039;Author&#039;;
 * Author.fields = {
 *   books: many({
 *     to: &#039;Book&#039;,
 *     relatedName: &#039;authors&#039;,
 *     through: &#039;Authorship&#039;,
 *
 *     // this is optional, since Redux-ORM can figure
 *     // out the through fields itself as there aren&#039;t
 *     // multiple foreign keys pointing to the same models.
 *     throughFields: [&#039;author&#039;, &#039;book&#039;],
 *   })
 * };
 *
 * class Book extends Model {}
 * Book.modelName = &#039;Book&#039;;
 * ```
 *
 * You should only define the many-to-many relationship on one side. In the
 * above case of Authors to Books through Authorships, the relationship is
 * defined only on the Author model.
 *
 * @param  {Object} options - options
 * @param  {string} options.to - the `modelName` attribute of the target Model.
 * @param  {string} [options.through] - the `modelName` attribute of the through Model which
 *                                    must declare at least one foreign key to both source and
 *                                    target Models. If not supplied, Redux-Orm will autogenerate
 *                                    one.
 * @param  {string[]} [options.throughFields] - this must be supplied only when a custom through
 *                                            Model has more than one foreign key pointing to
 *                                            either the source or target mode. In this case
 *                                            Redux-ORM can&#039;t figure out the correct fields for
 *                                            you, you must provide them. The supplied array should
 *                                            have two elements that are the field names for the
 *                                            through fields you want to declare the many-to-many
 *                                            relationship with. The order doesn&#039;t matter;
 *                                            Redux-ORM will figure out which field points to
 *                                            the source Model and which to the target Model.
 * @param  {string} [options.relatedName] - the attribute used to access a QuerySet
 *                                          of source Models from target Model.
 * @return {ManyToMany}
 */
export function many(...args) {
    return new ManyToMany(...args);
}

/**
 * Defines a one-to-one relationship. In database terms, this is a foreign key with the
 * added restriction that only one entity can point to single target entity.
 *
 * The arguments are the same as with `fk`. If `relatedName` is not supplied,
 * the source model name in lowercase will be used. Note that with the one-to-one
 * relationship, the `relatedName` should be in singular, not plural.
 * @param  {string|boolean} toModelNameOrObj - the `modelName` property of
 *                                           the Model that is the target of the
 *                                           foreign key, or an object with properties
 *                                           `to` and optionally `relatedName`.
 * @param {string} [relatedName] - if you didn&#039;t pass an object as the first argument,
 *                                 this is the property name that will be used to
 *                                 access a Model the foreign key is defined from,
 *                                 from the target Model.
 * @return {OneToOne}
 */
export function oneToOne(...args) {
    return new OneToOne(...args);
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
